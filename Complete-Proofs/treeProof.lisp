; ****************** BEGIN INITIALIZATION FOR ACL2s MODE ****************** ;
; (Nothing to see here!  Your actual file is after this initialization code);

#+acl2s-startup (er-progn (assign fmt-error-msg "Problem loading the CCG book.~%") (value :invisible))
(include-book "acl2s/ccg/ccg" :uncertified-okp nil :dir :system :ttags ((:ccg)) :load-compiled-file nil);v4.0 change

;Common base theory for all modes.
#+acl2s-startup (er-progn (assign fmt-error-msg "Problem loading ACL2s base theory book.~%") (value :invisible))
(include-book "acl2s/base-theory" :dir :system :ttags :all)


#+acl2s-startup (er-progn (assign fmt-error-msg "Problem loading ACL2s customizations book.~%Please choose \"Recertify ACL2s system books\" under the ACL2s menu and retry after successful recertification.") (value :invisible))
(include-book "custom" :dir :acl2s-modes :ttags :all)

#+acl2s-startup (er-progn (assign fmt-error-msg "Problem setting up ACL2s mode.") (value :invisible))

;Settings common to all ACL2s modes
(acl2s-common-settings)
;(acl2::xdoc acl2s::defunc) ;; 3 seconds is too much time to spare -- commenting out [2015-02-01 Sun]

(acl2::xdoc acl2s::defunc) ; almost 3 seconds

; Non-events:
;(set-guard-checking :none)

(acl2::in-package "ACL2S")

; ******************* END INITIALIZATION FOR ACL2s MODE ******************* ;
;$ACL2s-SMode$;ACL2s
;; ALL -> ALL
;; The tree swap function swaps the cdar and the 
;; cdr of the list if the first element of the list
;; is a nested list
(definec tree-swap (tr :all) :all
  (cond ((and (consp tr) (consp (car tr))) 
         (cons (cons (caar tr) 
                     (tree-swap (cdr tr))) 
               (tree-swap (cdar tr))))
        (t tr)))

(check= (tree-swap '((1) (2) (3) (4) 5)) '((1 (2 (3 (4 5))))))
(check= (tree-swap '((1 2) 3)) '((1 3) 2))
(check= (tree-swap '((1 2)(3 4)(5 6))) '((1 (3 (5) 6) 4 ) 2))
(check= (tree-swap '((1 2) 3 4 5 6)) '((1 3 4 5 6) 2))
(check= (tree-swap '((1 2 3) 4 5 6)) '((1 4 5 6) 2 3))
(check= (tree-swap '(1 2 3)) '(1 2 3))

;; TL X TL -> TL
;; The append function appends two lists
(definec app2 (a :tl b :tl) :tl
  (if (endp a)
      b
    (cons (first a) (app2 (rest a) b))))

;; TL -> TL
;; The rev2* function is the deep version of rev2, reversing any 
;; lists that may be nested
(definec rev2* (l* :tl) :tl
  (cond ((lendp l*) ())
        ((tlp (car l*)) 
         (app2 (rev2* (cdr l*)) 
               (list (rev2* (car l*)))))
        (t (app2 (rev2* (cdr l*)) (list (car l*))))))

(check= (rev2* '(1 2 3)) '(3 2 1))
(check= (rev2* '((1 2) 3)) '(3 (2 1)))
(check= (rev2* '((1 2)(3 4))) '((4 3)(2 1)))
(check= (rev2* '(1 (2 (3 4)))) '(((4 3) 2) 1))

;; Quick check to make sure that there are no counter examples
(test? 
 (implies (tlp x)
          (equal (rev2* (tree-swap (tree-swap (rev2* x))))
                 x)))

#|
;; manual breakdown which led to discovery of tree-swap-cdar

(cons (cons (caar x) (tree-swap (cdr x))) (tree-swap (cdar x))) ;; Tree-swap of x

;; Tree-swap of tree-swap of x
(cons (cons (caar (cons (cons (caar x) 
                              (tree-swap (cdr x))) 
                        (tree-swap (cdar x)))) 
            (tree-swap (cdr (cons (cons (caar x) (tree-swap (cdr x)))
                                  (tree-swap (cdar x)))))) 
      (tree-swap (cdar (cons (cons (caar x) 
                                   (tree-swap (cdr x))) 
                             (tree-swap (cdar x))))))


(cons (cons (caar x) 
            (tree-swap (tree-swap (cdar x)))) 
      (tree-swap (tree-swap (cdr x))))

(cons (cons (caar x) 
            (cdar x)) 
      (cdr x))

(cons (car x)
      (cdr x))
|#


;; This helps ACL2 deal with inverting tree-swap of cdar, which isn't handled by the autogenerated induction
(defthm tree-swap-cdar
  (implies (and (tlp x) (consp (car x)))
           (equal (tree-swap (tree-swap (cdar x)))
                  (cdar x))))


;; The main conjecture reduces to this, a lemma regarding the invertibility of the tree swap function
(defthm tree-swap-swap
  (implies (tlp x)
           (equal (tree-swap (tree-swap x))
                  x)))

;; The main conjecture is proving that the tree swap of the tree swap of the reverse of the list
;; is the same as the original list when reversed
(defthm rev-tree-swap-swap
  (implies (tlp x)
           (equal (rev2* (tree-swap 
                          (tree-swap (rev2* x))))
                  x)))